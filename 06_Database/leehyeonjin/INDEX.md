# 데이터베이스 인덱스(Index)

---

### 데이터베이스 인덱스 정의

**목적**

RDBMS에서 검색 속도를 높이기 위한 기술.

테이블의 컬럼을 색인화 하여 따로 파일로 저장.

⇒ 해당 테이블의 레코드를 Full Scan 하지 않음.

⇒ 색인화된 인덱스 파일 검색으로 검색 속도 향상.
</br></br>

**과정**

테이블의 생성하면, MYD, MYI, FRM 3개의 파일이 생성됨.

- MYD : 실제 데이터가 있는 파일.
- MYI : 인덱스 정보가 들어가 있는 파일.
- FRM : 테이블 구조가 저장되어 있는 파일.

인덱스를 사용하지 않는 경우, MYI 파일은 비어있음.

그러나 인덱싱하는 경우 MYI 파일이 생성됨.

⇒ 인덱싱하면 이후 사용자가 select 쿼리로 인덱스를 사용하는 컬럼을 탐색하면 MYI 파일의 내용을 검색.

---

### 인덱스 사용 상황 분석

**사용하면 좋은 경우**

대량의 데이터를 검색하는 경우.

정렬된 결과를 출력하는 경우.

Join 연산을 수행하는 경우.

유니크한 값을 가져오는 경우.

검색 빈도가 높은 경우.
</br></br>

**사용을 피해야 하는 경우**

데이터 중복도가 높은 컬럼.

DML이 자주 일어나는 컬럼(Insert, Update, Delete).
</br></br>

**인덱스 사용 단점**

- 인덱스 생성시 .mdb 파일 크기가 증가함.
- 한 페이지를 동시에 수정할 수 있는 병행성이 줄어듦.
- 인덱스된 필드에서 데이터를 업데이트하거나, 레코드를 추가 또는 삭제시 성능이 떨어짐.
- 데이터 변경 작업이 자주 일어나는 경우, 인덱스를 재작성해야 하므로 성능에 영향을 미침.

---

### 인덱스 & DML

인덱스는 항상 최신 데이터를 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있음.

따라서 인덱스가 적용된 컬럼에 Insert, Update, Delete가 수행된다면 다음의 연산을 각각 추가적으로 해주어야 하며, 그에 따른 오버헤드가 발생함.

- Insert : 새로운 데이터에 대한 인덱스를 추가.
- Delete : 삭제하는 데이터의 인덱스를 더이상 사용하지 않는다는 작업 진행.
- Update : 기존의 인덱스를 사용하지 않음으로 처리하고, 갱신된 데이터에 대해 인덱스를 추가.

---

### 인덱스의 자료구조

**1. 해시테이블(Hash Table)**

키와 해시값 쌍으로 이루어진 자료구조.

O(1) 시간복잡도를 가지고 있어, 상당히 빠른 검색이 가능함.

[검색 방식]

- 키를 해시 함수를 사용하여 해시값으로 변환.
- 해당 해시값에 해당하는 값을 찾아서 검색.

[한계]

- 해시 테이블은 검색 속도가 매우 빠르지만, 데이터의 분포에 따라 충돌이 발생할 수 있음.
- 해시는 등호(=) 연산에만 특화되어 있어 부등호 연산(>, <)이 자주 사용되는 데이터베이스 검색을 위해서는 적합하지 않음.
</br></br>

**2. B- Tree**

균형 잡힌 이진 검색 트리로 이루어진 자료구조.

O(logN) 시간복잡도를 가지고 있어, 검색 속도 향상에 도움이 됨.

각 노드 내 데이터들은 항상 정렬된 상태 유지 → 데이터와 데이터 사이의 범위를 이용하여 자식노드를 가짐.
</br></br>

**3. B+ Tree**

균형 잡힌 이진 검색 트리로 이루어진 자료구조.

O(logN) 시간복잡도를 가지고 있어, 검색 속도 향상에 도움이 됨.

[B- Tree vs B+ Tree]

B+ Tree는 내부 노드와 단말 노드로 구분됨.

모든 데이터는 단말 노드에만 저장되며, 내부 노드에는 검색을 위한 인덱스만 저장.

모든 단말 노드가 연결리스트로 연결되어 있으며, 순차적으로 저장되어 있음.

- 단말 노드에만 데이터를 저장하여 메모리 확보 ⇒ 하나의 노드에 더 많은 포인터를 가질 수 있어 트리의 높이가 더 낮아지므로 검색속도도 향상.
- Full Scan의 경우 단말노드에 데이터가 순차적으로 연결되어 저장되므로 ⇒ 선형시간만 소요됨.

---

### 클러스터 인덱스 vs 넌클러스터 인덱스

**클러스터 인덱스**

<img width="692" alt="Untitled" src="https://github.com/hgene0929/ComputerScience/assets/90823532/a6ce3157-4bb7-4908-ac7b-2412b5e47ac7">

테이블당 1개씩만 허용됨.

물리적으로 행을 재배열.

PK 설정시 그 컬럼은 자동으로 클러스터 인덱스가 생성됨.

테이블 자체가 인덱스 → 따로 인덱스 페이지를 생성하지 않음.

데이터 입력, 수정, 삭제시 항상 정렬 상태를 유지.

넌클러스터형 인덱스보다 검색 속도는 빠르지만, 데이터의 입력, 수정, 삭제는 느림.

30% 이내에서 사용해야 좋은 선택도를 가지게 됨.
</br></br>

**넌클러스터 인덱스**

<img width="653" alt="Untitled (1)" src="https://github.com/hgene0929/ComputerScience/assets/90823532/0fdf83a1-30cb-4571-8383-3e32794a817f">

테이블당 약 240개의 인덱스를 생성 가능.

인덱스 페이지는 로그파일에 저장됨.

레코드의 원본은 정렬되지 않고, 인덱스 페이지만 정렬됨.

인덱스 자체의 리프 페이지는 데이터가 아니라 데이터가 위치하는 포인터.

클러스터형 검색 속도는 더 느리지만 데이터의 입력, 수정, 삭제는 더 빠름.

인덱스를 생성할 때 데이터 페이지는 그냥 둔 상태에서 별도의 인덱스 페이지를 따로 만들기 때문에 용량을 더 차지함.

3% 이내에서 사용해야 좋은 선택도를 가짐.
