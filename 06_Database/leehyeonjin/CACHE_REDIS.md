# 캐싱 & Redis

---

### Cache 정의

미리 결과를 저장하고, 나중에 요청이 오면 그 요청에 대해서 DB 또는 API를 참조하지 않고 캐시에 접근하여 요청을 처리하는 기법.

> 💡 **파레토의 법칙(Pareto’s Law)**
>
> - cache의 전제가 되는 개념.
> - 80%의 결과는 20%의 원인으로 인해 발생.

즉, 캐시는 모든 결과를 캐싱할 필요가 없으며 서비스를 할 때 많이 사용되는 20%만 캐싱함으로써 전체적으로 효율을 끌어올릴 수 있음.

---

### Cache 사용

**캐시 사용을 생각해보게 되는 상황**

서비스를 처음 운영할 때는 WEB-WAS-DB 정도로 작게 인프라를 구축하는데, 사용자가 늘어나면 DB에 무리가 가기 시작함.

- DB는 데이터를 물리 디스크에 직접 쓰기 때문에 서버에 문제가 발생해도 데이터가 손실되지는 않음.
- 그러나 매 트랜잭션마다 디스크에 접근해야하므로 부하가 많아지면 성능이 떨어짐.

따라서 사용자가 늘어나면 DB를 스케일 인 또는 스케일 아웃하는 방식 이외에도 캐시 서버를 검토해볼 수 있음.
</br></br>

**캐시 사용 구조**

<img width="691" alt="Untitled" src="https://github.com/hgene0929/ComputerScience/assets/90823532/96fdf07b-a161-4a5e-9b6a-b5ca2bd914a2">

1. 클라이언트로부터 요청을 받음.
2. 캐시와 작업 수행.
    - Cache Hit : 캐시 서버에 데이터가 있는지 확인 하고 있다면 DB에 가지 않고 바로 캐시의 데이터 반환.
3. 실제 DB와 작업 수행.
    - Cache Miss : 캐시 서버에 데이터가 없으면 DB에 데이터를 요청하여 원하는 데이터를 요청해서 조회한 후 그 데이터를 클라이언트에게 제공.
4. 다시 캐시와 작업 수행.
</br></br>

**캐시 사용 방식**

**1. Look Aside Cache (Lazy Loading)**

대부분의 캐시를 사용한 개발이 해당 프로세스를 따름.

동작 :

- 캐시에 데이터 존재 유무 확인.
- 데이터가 있다면 캐시의 데이터 사용.
- 데이터가 없다면 캐시의 실제 DB 데이터 사용.
- DB에서 가져온 데이터를 캐시에 저장.
</br></br>

**2. Write Back**

쓰기 작업이 굉장히 많아서, insert 쿼리를 일일이 날리지 않고 한꺼번에 배치 처리를 하기 위해 사용됨.

DB에서 디스크를 접근하는 횟수가 줄어들기 때문에 성능향상 가능.

그러나 DB에 데이터를 저장하기 전에 캐시 서버가 죽으면 데이터가 유실된다는 문제점 발생.

동작 :

- 모든 데이터를 캐시에 저장.
- 캐시의 데이터를 일정 주기마다 DB에 한꺼번에 저장(배치).
- DB에 저장한 데이터를 캐시에서 제거.

---

### 인메모리 데이터베이스

<img width="673" alt="Untitled (1)" src="https://github.com/hgene0929/ComputerScience/assets/90823532/ce4853d3-18a6-4813-8309-2a158d7a68d7">

데이터 저장을 메모리에 의존하는 특수 제작된 데이터베이스.

- 디스크 혹은 SSD에 데이터를 저장하지 않음.

디스크에 접근을 없애므로 최소한의 응답시간을 가지도록 설계되었음.

---

### Memcached

빠른 오픈 소스 인메모리 키-값 데이터 구조 스토어(NoSQL).
</br></br>

**초창기 캐시시스템**

초창기의 캐시시스템은 노드가 완전히 독립적으로 운영되어 데이터를 조회하거나, 저장시 어느 서버(어떤 캐시서버?)를 이용해야할지 관리해야 함.

**Memcached**

consistent hash 알고리즘을 사용하여 물리적인 별도의 캐시 서버를 로직 상 하나의 서버로 사용할 수 있도록 함 ⇒ 능률적이고 대용량 캐시 시스템 구축.

---

### Redis 정의

빠른 오픈 소스 인메모리 키-값 데이터 구조 스토어(NoSQL).
</br></br>

**Redis의 영속성**

Redis는 영속성을 보장하기 위해 데이터를 디스크에 저장할 수 있음. 서버가 내려가더라도 디스크에 저장된 데이터를 읽어서 메모리에 로딩.

데이터를 디스크에 저장하는 방식 :

1. RDB(Snapshotting) 방식 : 순간적으로 메모리에 있는 내용 전체를 디스크에 옮겨 담는 방식.
2. AOP(Append On File) 방식 : Redis의 모든 write/update 연산 자체를 모두 log 파일에 기록하고, 서버가 셧다운 되면 재실행해서 다시 만들어둠.
</br></br>

**Redis의 컬렉션**

Redis의 Key에는 다양한 데이터타입이 저장될 수 있음.

<img width="697" alt="Untitled (2)" src="https://github.com/hgene0929/ComputerScience/assets/90823532/49e383ea-6ca1-4f5e-b7f9-d31251c8a682">

**Redis의 싱글 스레드 사용**

Redis는 싱글 스레드를 사용하므로 연산을 원자적으로 처리(한 트랜잭션당 하나의 연산만 수행)하여 race condition이 거의(더블클릭 이슈 제외 모두) 발생하지 않음.

---

### Memcahced vs Redis

|  | Redis | Memcached |
| --- | --- | --- |
| 스레드 | 싱글 스레드 | 멀티 스레드 |
| 데이터 구조 | 다양한 자료구조 지원 | String, Integer만 지원 |
| 데이터 저장 | 메모리, 디스크 | 메모리 |
| 처리 속도 | Memcached에 비해서는 느림 | 디스크를 거치지 않아 Redis보다 조금 빠름 |
| 영속성 | O | X |
