# JVM 구조와 Java 실행과정

---

### JVM **정의**

Java Virtual Machine(자바 가상 머신)의 줄임말.

OS에 종속받지 않고, CPU가 Java를 인식하고 실행할 수 있게 해주는 가상 컴퓨터.

> 💡 **플랫폼 독립적**
> 
> 특정 운영체제나 기계에 의존적이지 않음.

--- 

### JVM 구조

<img width="507" alt="Untitled" src="https://github.com/hgene0929/ComputerScience/assets/90823532/57a1cc1f-b94f-441e-9133-c547497f6c0a">

**1. 클래스 로더**

JVM 내로 클래스 파일(바이트 코드 뭉치)을 로드하고, 런타임 데이터 영역에 배치.
</br></br>

**2. 실행 엔진**

클래스를 실행시킴.

인간이 보기 편한 형태의 바이트 코드를 기계가 실행할 수 있는 형태로 변환.

클래스 파일 내부 바이트 코드를 읽어들임.

- **인터프리터** : 한 줄씩 읽어서 실행.
- **JIT(Just In Time) 컴파일러** : 반복되는 코드를 한꺼번에 읽어서 실행.
- **가비지 콜렉터** : 더이상 사용되지 않는 인스턴스를 찾아서 메모리에서 삭제.
</br></br>

**3. 런타임 데이터 영역**

<img width="486" alt="Untitled (1)" src="https://github.com/hgene0929/ComputerScience/assets/90823532/51fcfaff-d62f-441e-901e-a3a5633ae06c">

프로그램을 수행하기 위해 OS에서 할당받은 메모리 공간.

**PC 레지스터 :**
* 스레드가 시작될 때마다 생성되는 공간으로 스레드마다 하나씩 존재.
* 현재 수행 중인 JVM 명령의 주소 저장.
</br>

**JVM 스택 :**
* 프로그램 실행과정에서 임시로 할당되었다가 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역.
* 메소드 호출시마다 각각의 스택 프레임(그 메소드만을 위한 공간)을 생성하고, 메소드 수행이 끝나면 프레임 별로 삭제.
</br>

**Native Method 스택 :**
* Java 프로그램이 컴파일되어 생성되는 바이트 코드가 아닌 실제 실행가능한 기계어로 작성된 프로그램을 실행시키는 영역.
* Java가 아닌 다른 언어로 작성된 코드를 위한 공간.
* JNI(Java Native Interface)를 통해 바이트 코드로 전환하여 저장.
* 일반 프로그램처럼 커널이 스택을 잡아 독자적으로 프로그램을 실행시킴.
</br>

**Method(= Class = Static) 영역 :**
* 클래스 정보를 처음 메모리 공간에 올릴 때 초기화되는 대상을 저장.
  * Runtime Constant Pool : Method 영역에 존재하는 별도의 관리 영역으로, 상수 자료형을 저장하여 참조하고 중복을 막는 역할을 수행.
</br>

**heap 영역 :**

<img width="490" alt="Untitled (2)" src="https://github.com/hgene0929/ComputerScience/assets/90823532/50133971-7b88-44ea-8538-6b40a0ebf172">

- 객체를 저장하는 가상메모리 공간.
- new 연산자로 생성되는 객체와 배열을 저장.
- Method 영역에 올라온 클래스들만 객체로 생성가능.
- New/Young Generation :
    - 생명 주기가 짧은 객체를 GC 대상으로 하는 영역.
    - 여기서 일어나는 GC는 Minor GC.
    - Eden : 객체들이 최초로 생성되는 공간.
    - Survivor 0,1 : Eden에서 참조되는 객체들이 저장되는 공간.
- Old Generation :
    - 생명 주기가 긴 객체를 GC 대상으로 하는 영역.
    - 여기서 일어나는 GC는 Major GC.
    - Minor GC에 비해 속도가 느림.
    - New/Young 영역에서 일정시간 참조되고 있는 살아남은 객체들이 저장되는 공간.

---

### Java 실행과정

1. 프로그램이 실행되면 JVM은 OS로부터 프로그램이 필요로 하는 메모리를 할당받는다.
2. Java 컴파일러가 Java 소스코드를 읽어 바이트 코드로 변환시킨다.
3. 클래스로더를 통해 클래스 파일(바이트 코드 뭉치)들을 JVM으로 로딩한다.
4. 클래스 로더는 동적 로딩을 통해 필요한 클래스들을 로딩하고 링크하여 런타임 데이터 영역에 배치한다.
5. 런타임 데이터 영역은 메모리에 올라온 바이트 코드를 실행한다(인터프리터 방식, JIT 컴파일러 방식).
